<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Group Glide — Crossfade Steps (Single-Note Rider)</title>
<style>
  :root{--bg:#0b0f14;--panel:#121826;--line:#1f2a3a;--text:#e8eef6;--muted:#9fb0c7;--accent:#4fb38f;--danger:#e57373}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:560px;margin:0 auto;padding:14px}
  h1{font-size:18px;margin:6px 0 10px;font-weight:600}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;margin:10px 0}
  .row{display:flex;flex-direction:column;gap:6px;margin:10px 0}
  label{color:var(--muted);font-size:12px}
  input[type=range]{width:100%}
  select{width:100%;padding:10px;border:1px solid var(--line);border-radius:10px;background:#0f1420;color:var(--text)}
  button{appearance:none;border:1px solid var(--line);background:#0f1420;color:var(--text);padding:12px;border-radius:12px;cursor:pointer;width:100%}
  .btnbar{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .primary{background:var(--accent);border-color:#2f7f64;color:#07140f;font-weight:700}
  .danger{background:#221417;border-color:#5c2a31;color:#ffd8d8}
  .small{color:var(--muted);font-size:12px}
  .readout{display:flex;justify-content:space-between;font-variant-numeric:tabular-nums}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .badge{display:inline-block;background:#0f1420;border:1px solid var(--line);padding:2px 8px;border-radius:999px;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Group Glide — Single Note with Scale Crossfade</h1>

  <div class="card">
    <div class="btnbar">
      <button id="startBtn" class="primary">Start</button>
      <button id="stopBtn" class="danger">Stop</button>
    </div>
    <div class="row small">
      <div class="readout">
        <div>Lower: <span id="noteA" class="badge mono">—</span></div>
        <div>Upper: <span id="noteB" class="badge mono">—</span></div>
      </div>
      <div class="readout"><div>Mix A→B:</div><div><span id="mixDisp" class="mono">0.00</span></div></div>
      <div class="readout"><div>Hz A/B:</div><div><span id="hzDisp" class="mono">— / —</span></div></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <label>Acceleration (springs back to center)</label>
      <input id="accel" type="range" min="-1" max="1" step="0.001" value="0">
      <div class="readout small"><span>Decel</span><span>Neutral</span><span>Accel</span></div>
      <div class="small">Tap/drag right = pitch up within scale. Left = down. Release → auto-center.</div>
    </div>

    <div class="row">
      <label>Home Region (neutral position within note window)</label>
      <input id="home" type="range" min="0" max="1" step="0.001" value="0.35">
      <div class="readout small"><span>Lower</span><span>—</span><span>Higher</span></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <label>Root / Scale</label>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <select id="root"></select>
        <select id="scale"></select>
      </div>
    </div>

    <div class="row">
      <label>Octave Span</label>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <select id="baseOct">
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option>
        </select>
        <select id="octSpan">
          <option value="1">1 octave</option>
          <option value="2" selected>2 octaves</option>
          <option value="3">3 octaves</option>
        </select>
      </div>
      <div class="small">Each rider picks a different Home Region so the group forms a chord at rest.</div>
    </div>

    <div class="row">
      <label>Response & Tone</label>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div>
          <span class="small">Glide (ms)</span>
          <input id="glideMs" type="range" min="10" max="1200" step="10" value="220">
        </div>
        <div>
          <span class="small">Spring (fps)</span>
          <input id="spring" type="range" min="10" max="120" step="1" value="45">
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px">
        <div>
          <span class="small">Brightness</span>
          <input id="bright" type="range" min="400" max="8000" step="1" value="2500">
        </div>
        <div>
          <span class="small">Air</span>
          <input id="air" type="range" min="0" max="1" step="0.001" value="0.08">
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px">
        <div>
          <span class="small">Reverb</span>
          <input id="rev" type="range" min="0" max="1" step="0.001" value="0.45">
        </div>
        <div>
          <span class="small">Output</span>
          <input id="out" type="range" min="0" max="1" step="0.001" value="0.9">
        </div>
      </div>
    </div>
  </div>

  <p class="small">Engine plays two adjacent scale steps at all times and fades between them; each step is a small partial cluster with gentle detune to keep the “shimmer” feel while distributing the harmony across riders.</p>
</div>

<script>
(()=> {
  // ---------- Music helpers ----------
  const A4=440, NOTES=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const noteIndex = Object.fromEntries(NOTES.map((n,i)=>[n,i]));
  const midiToFreq = m => A4 * Math.pow(2,(m-69)/12);
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const SCALES = {
    "Ionian (Major)":[0,2,4,5,7,9,11],
    "Dorian":[0,2,3,5,7,9,10],
    "Phrygian":[0,1,3,5,7,8,10],
    "Lydian":[0,2,4,6,7,9,11],
    "Mixolydian":[0,2,4,5,7,9,10],
    "Aeolian (Natural Minor)":[0,2,3,5,7,8,10],
    "Harmonic Minor":[0,2,3,5,7,8,11],
    "Whole Tone":[0,2,4,6,8,10],
    "Octatonic (HW)":[0,1,3,4,6,7,9,10]
  };

  function buildScaleTable(rootName, baseOct, octSpan, scaleName){
    const rootSemis = noteIndex[rootName] + baseOct*12;
    const degs = SCALES[scaleName];
    const out=[];
    for(let o=0;o<octSpan;o++) for(const d of degs) out.push(rootSemis + d + o*12);
    return out;
  }
  function midiName(m){ const n = ((m%12)+12)%12, o = Math.floor(m/12)-1; return NOTES[n]+o; }

  // ---------- Audio graph ----------
  let ctx, master, lowpass, airGain, reverbSend, convolver, noise, outGain;

  function mkReverbImpulse(seconds=2.7, decay=2.2){
    const rate = ctx.sampleRate, len = Math.max(1,(seconds*rate)|0);
    const buf = ctx.createBuffer(2,len,rate);
    for(let ch=0; ch<2; ch++){
      const d = buf.getChannelData(ch);
      for(let i=0;i<len;i++){ const t=i/len, env=Math.pow(1-t,decay); d[i]=(Math.random()*2-1)*env; }
    }
    return buf;
  }

  class PartialStack {
    constructor({partials=4, detuneCents=10, baseGain=0.22}={}){
      this.stackGain = ctx.createGain(); this.stackGain.gain.value = 0;
      this.partials = [];
      for(let i=0;i<partials;i++){
        const o = ctx.createOscillator();
        o.type = (i%2 ? "triangle" : "sawtooth");
        const g = ctx.createGain(); g.gain.value = baseGain * Math.pow(0.7,i);
        const dLFO = ctx.createOscillator(); dLFO.type="sine"; dLFO.frequency.value = 0.08 + Math.random()*0.25;
        const dAmt = ctx.createGain(); dAmt.gain.value = detuneCents * (0.6 + Math.random()*0.8); // cents p-p
        dLFO.connect(dAmt).connect(o.detune);
        o.connect(g).connect(this.stackGain);
        o.start(); dLFO.start();
        this.partials.push({o,g,dLFO,dAmt});
      }
    }
    connect(node){ this.stackGain.connect(node); }
    setGain(v, tConst=0.04){ this.stackGain.gain.setTargetAtTime(v, ctx.currentTime, tConst); }
    tuneTo(freq, glideMs=180){
      const t = ctx.currentTime, k = Math.max(0.005, glideMs/1000*0.25);
      for(const p of this.partials){
        p.o.frequency.cancelScheduledValues(t);
        p.o.frequency.setTargetAtTime(freq, t, k);
      }
    }
  }

  function setup(){
    ctx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive"});
    const mix = ctx.createGain();

    // Tone chain
    const mildSat = ctx.createWaveShaper();
    mildSat.curve = (()=>{ const n=256,c=new Float32Array(n); for(let i=0;i<n;i++){const x=i/(n-1)*2-1;c[i]=Math.tanh(1.6*x);} return c; })();
    lowpass = ctx.createBiquadFilter(); lowpass.type="lowpass"; lowpass.frequency.value=2500;

    // Air (filtered noise)
    noise = ctx.createBufferSource();
    const nbuf = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
    const nd = nbuf.getChannelData(0); for(let i=0;i<nd.length;i++) nd[i]=(Math.random()*2-1);
    noise.buffer = nbuf; noise.loop = true;
    const airBP = ctx.createBiquadFilter(); airBP.type="bandpass"; airBP.Q.value=0.7; airBP.frequency.value=5000;
    airGain = ctx.createGain(); airGain.gain.value = 0.08;

    // Reverb
    reverbSend = ctx.createGain(); reverbSend.gain.value=0.45;
    convolver = ctx.createConvolver(); convolver.buffer = mkReverbImpulse();
    const revGain = ctx.createGain(); revGain.gain.value=1.0;

    // Output
    outGain = ctx.createGain(); outGain.gain.value = 0.9;
    master = ctx.createGain(); master.gain.value = 1.0;

    // Route
    mix.connect(mildSat).connect(lowpass).connect(outGain).connect(master).connect(ctx.destination);
    mix.connect(reverbSend).connect(convolver).connect(revGain).connect(master);
    noise.connect(airBP).connect(airGain).connect(master);
    noise.start();

    return {mix};
  }

  // ---------- Two-stack crossfade engine ----------
  let running=false, springTimer=null;
  let table=[], lastLower=null, lastUpper=null;
  let stackA, stackB;

  // UI refs
  const $=s=>document.querySelector(s);
  const startBtn=$('#startBtn'), stopBtn=$('#stopBtn');
  const noteAEl=$('#noteA'), noteBEl=$('#noteB'), mixDisp=$('#mixDisp'), hzDisp=$('#hzDisp');
  const accelEl=$('#accel'), homeEl=$('#home');
  const rootSel=$('#root'), scaleSel=$('#scale'), baseOctSel=$('#baseOct'), octSpanSel=$('#octSpan');
  const glideMsEl=$('#glideMs'), springEl=$('#spring'), brightEl=$('#bright'), airEl=$('#air'), revEl=$('#rev'), outEl=$('#out');

  // Populate menus
  (function initMenus(){
    for(const n of NOTES){ const o=document.createElement('option'); o.textContent=n; rootSel.appendChild(o); }
    rootSel.value="D";
    for(const s of Object.keys(SCALES)){ const o=document.createElement('option'); o.textContent=s; scaleSel.appendChild(o); }
    scaleSel.value="Dorian";
  })();

  const state = {
    root:"D", scale:"Dorian",
    baseOct:3, octSpan:2,
    home:0.35, accel:0,
    glideMs:220, springFps:45,
    brightness:2500, air:0.08, reverb:0.45, output:0.9
  };

  function rebuildTable(){
    table = buildScaleTable(state.root, state.baseOct, state.octSpan, state.scale);
    if(table.length<2) table.push(table[0]+12);
    // make sure current tuning lines up
    updatePitch(true);
  }

  // Map position (home + accel) to continuous scale index
  function computePosition(){
    const maxIdx = table.length-1;
    const span = Math.max(1, Math.round(table.length*0.4)); // reach ~40% of window with full accel
    const homeIdx = state.home * maxIdx;
    const pos = clamp(homeIdx + state.accel*span, 0, maxIdx);
    return pos;
  }

  function setBrightness(hz){ lowpass && lowpass.frequency.setTargetAtTime(hz, ctx.currentTime, 0.1); }
  function setAir(a){ airGain && airGain.gain.setTargetAtTime(a, ctx.currentTime, 0.15); }
  function setReverb(a){ reverbSend && reverbSend.gain.setTargetAtTime(a, ctx.currentTime, 0.2); }
  function setOutput(a){ outGain && outGain.gain.setTargetAtTime(a, ctx.currentTime, 0.05); }

  function updatePitch(force=false){
    if(!table.length || !stackA || !stackB) return;

    const pos = computePosition();
    const lowerIndex = Math.floor(pos);
    const upperIndex = clamp(lowerIndex+1, 0, table.length-1);
    const mix = pos - lowerIndex;

    const midiA = table[lowerIndex];
    const midiB = table[upperIndex];
    const fA = midiToFreq(midiA);
    const fB = midiToFreq(midiB);

    // Tuning (only if indices changed or force)
    if(force || lowerIndex!==lastLower){
      stackA.tuneTo(fA, state.glideMs);
      lastLower = lowerIndex;
    }
    if(force || upperIndex!==lastUpper){
      stackB.tuneTo(fB, state.glideMs);
      lastUpper = upperIndex;
    }

    // Crossfade; never both zero -> tone always present at neutral
    stackA.setGain(1 - mix, 0.05);
    stackB.setGain(mix, 0.05);

    // Readouts
    noteAEl.textContent = midiName(midiA);
    noteBEl.textContent = midiName(midiB);
    mixDisp.textContent = mix.toFixed(2);
    hzDisp.textContent = `${fA.toFixed(2)} / ${fB.toFixed(2)}`;
  }

  function startSpring(){
    if(springTimer) return;
    const fps = clamp(parseInt(springEl.value,10)||45,10,120);
    const dt = 1000/fps;
    let dragging=false;
    const onDown=()=>{dragging=true;};
    const onUp =()=>{dragging=false;};
    accelEl.addEventListener('pointerdown', onDown);
    accelEl.addEventListener('pointerup', onUp);
    accelEl.addEventListener('pointercancel', onUp);

    springTimer = setInterval(()=>{
      if(dragging) return;
      state.accel = lerp(state.accel, 0, 0.18);
      if(Math.abs(state.accel)<0.002) state.accel = 0;
      accelEl.value = state.accel.toFixed(3);
      updatePitch(false);
    }, dt);
  }
  function stopSpring(){ if(springTimer){clearInterval(springTimer); springTimer=null;} }

  // Events
  accelEl.addEventListener('input', e => { state.accel = +e.target.value; updatePitch(false); });
  homeEl.addEventListener('input', e => { state.home = +e.target.value; updatePitch(true); });

  rootSel.addEventListener('input', e => { state.root = e.target.value; rebuildTable(); });
  scaleSel.addEventListener('input', e => { state.scale = e.target.value; rebuildTable(); });
  baseOctSel.addEventListener('input', e => { state.baseOct = +e.target.value; rebuildTable(); });
  octSpanSel.addEventListener('input', e => { state.octSpan = +e.target.value; rebuildTable(); });

  glideMsEl.addEventListener('input', e => { state.glideMs = +e.target.value; });
  springEl.addEventListener('input', () => { stopSpring(); startSpring(); });

  brightEl.addEventListener('input', e => { state.brightness = +e.target.value; setBrightness(state.brightness); });
  airEl.addEventListener('input', e => { state.air = +e.target.value; setAir(state.air); });
  revEl.addEventListener('input', e => { state.reverb = +e.target.value; setReverb(state.reverb); });
  outEl.addEventListener('input', e => { state.output = +e.target.value; setOutput(state.output); });

  startBtn.addEventListener('click', ()=>{
    if(!ctx){
      const {mix} = setup();
      // Two adjacent step stacks feeding mix
      stackA = new PartialStack({partials:4, detuneCents:12, baseGain:0.22});
      stackB = new PartialStack({partials:4, detuneCents:12, baseGain:0.22});
      stackA.connect(mix); stackB.connect(mix);
    }
    ctx.resume();
    setBrightness(state.brightness);
    setAir(state.air);
    setReverb(state.reverb);
    setOutput(state.output);
    rebuildTable();
    running=true;
    startSpring();
  });

  stopBtn.addEventListener('click', ()=>{
    running=false;
    stopSpring();
    if(outGain){ outGain.gain.setTargetAtTime(0, ctx.currentTime, 0.08); }
    setTimeout(()=>{ if(outGain) outGain.gain.setTargetAtTime(state.output, ctx.currentTime, 0.08); }, 300);
  });

  // Mobile unlock
  document.addEventListener('touchend', ()=>{ if(ctx && ctx.state!=="running") ctx.resume(); }, {passive:true});

  // Initial
  rebuildTable();
})();
</script>
</body>
</html>
