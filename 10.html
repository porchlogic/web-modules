<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Organic Deep String</title>
<style>
	body{margin:0;background:#05060a;color:#e6ecf5;font-family:system-ui;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh}
	button,input{margin:6px}
	.row{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<div class="row">
	<button id="start">Start Audio</button>
	<button id="noteLow">Low</button>
	<button id="noteMid">Mid</button>
	<button id="noteHigh">High</button>
</div>
<div class="row">
	<label>Depth <input id="depth" type="range" min="0" max="1" step="0.001" value="0.7"></label>
	<label>Bow <input id="bow" type="range" min="0" max="1" step="0.001" value="0.6"></label>
	<label>Tension <input id="tension" type="range" min="0" max="1" step="0.001" value="0.4"></label>
	<label>Air <input id="air" type="range" min="0" max="1" step="0.001" value="0.3"></label>
</div>

<script>
let ctx, master;
const voices = [];
const modes = [220, 420, 650, 1200, 2300]; // fake body modes Hz

function createVoice() {
	const v = {};

	v.gain = ctx.createGain();
	v.gain.gain.value = 0.0;

	// noise exciter
	const noiseBuffer = ctx.createBuffer(1, 44100, 44100);
	const data = noiseBuffer.getChannelData(0);
	for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
	v.noise = ctx.createBufferSource();
	v.noise.buffer = noiseBuffer;
	v.noise.loop = true;

	const noiseFilter = ctx.createBiquadFilter();
	noiseFilter.type = "bandpass";
	noiseFilter.frequency.value = 3000;
	noiseFilter.Q.value = 0.7;

	v.noiseGain = ctx.createGain();
	v.noiseGain.gain.value = 0.0;

	v.noise.connect(noiseFilter).connect(v.noiseGain);

	// harmonic oscillators
	v.partials = [];
	const partialCount = 6;
	for (let i = 1; i <= partialCount; i++) {
		const osc = ctx.createOscillator();
		osc.type = "sine";
		const g = ctx.createGain();
		g.gain.value = 0.0;
		osc.connect(g);
		v.partials.push({osc, gain: g, ratio: i});
	}

	// body filters (parallel)
	v.bodyFilters = modes.map(f => {
		const b = ctx.createBiquadFilter();
		b.type = "bandpass";
		b.frequency.value = f;
		b.Q.value = 4;
		return b;
	});
	const bodyMix = ctx.createGain();
	bodyMix.gain.value = 0.7;
	v.bodyFilters.forEach(b => v.noiseGain.connect(b));
	v.partials.forEach(p => v.bodyFilters.forEach(b => p.gain.connect(b)));
	v.bodyFilters.forEach(b => b.connect(bodyMix));

	// subtle space
	const delay = ctx.createDelay(0.2);
	delay.delayTime.value = 0.03;
	const fb = ctx.createGain();
	fb.gain.value = 0.25;
	bodyMix.connect(delay);
	delay.connect(fb);
	fb.connect(delay);
	const wet = ctx.createGain();
	wet.gain.value = 0.3;
	delay.connect(wet);

	// dry from body
	const dry = ctx.createGain();
	dry.gain.value = 0.9;
	bodyMix.connect(dry);

	// master for voice
	dry.connect(v.gain);
	wet.connect(v.gain);
	v.gain.connect(master);

	v.noise.start();
	v.partials.forEach(p => p.osc.start());

	v.f0 = 110;
	v.targetF0 = 110;

	voices.push(v);
	randomizeVoice(v);
	return v;
}

function setVoiceNote(v, f0) {
	v.targetF0 = f0;
}

function updateParams() {
	const depth = parseFloat(document.getElementById("depth").value);
	const bow = parseFloat(document.getElementById("bow").value);
	const tension = parseFloat(document.getElementById("tension").value);
	const air = parseFloat(document.getElementById("air").value);

	const now = ctx.currentTime;

	voices.forEach(v => {
		// smooth pitch
		v.f0 = v.f0 + (v.targetF0 - v.f0) * 0.05;

		// bow/exciter
		const bowLevel = 0.02 + bow * 0.25;
		v.noiseGain.gain.linearRampToValueAtTime(bowLevel, now + 0.03);

		// partials
		v.partials.forEach((p, idx) => {
			const baseAmp = (1 / (p.ratio ** 1.2)) * (0.4 + depth * 0.4);
			const mod = 1 + (Math.random() - 0.5) * 0.02; // micro jitter
			const amp = baseAmp * mod;
			p.gain.gain.linearRampToValueAtTime(amp, now + 0.05);

			const detuneCents = (Math.random() - 0.5) * (tension * 10);
			const freq = v.f0 * (p.ratio + 0.01 * idx * tension);
			p.osc.frequency.linearRampToValueAtTime(freq, now + 0.05);
			p.osc.detune.linearRampToValueAtTime(detuneCents, now + 0.05);
		});

		// air / body tweak
		v.bodyFilters.forEach((b, i) => {
			const base = modes[i];
			const spread = 1 + (i * 0.02 * tension);
			b.frequency.linearRampToValueAtTime(base * spread, now + 0.1);
			b.Q.linearRampToValueAtTime(3 + tension * 4, now + 0.1);
		});

		// overall voice gain
		const g = 0.5 + depth * 0.5;
		v.gain.gain.linearRampToValueAtTime(g, now + 0.05);
	});

	// air could map to wet amount etc. (left as simple here)
}

function randomizeVoice(v) {
	// can seed any per-voice random factors here if you extend it
}

function loop() {
	if (!ctx) return;
	updateParams();
	requestAnimationFrame(loop);
}

document.getElementById("start").onclick = () => {
	if (ctx) return;
	ctx = new (window.AudioContext || window.webkitAudioContext)();
	master = ctx.createGain();
	master.gain.value = 0.8;
	master.connect(ctx.destination);

	// create a small ensemble
	for (let i = 0; i < 3; i++) createVoice();

	loop();
};

document.getElementById("noteLow").onclick = () => {
	if (!ctx) return;
	voices.forEach((v,i)=>setVoiceNote(v, 55 * (1 + i*0.01)));
};
document.getElementById("noteMid").onclick = () => {
	if (!ctx) return;
	voices.forEach((v,i)=>setVoiceNote(v, 110 * (1 + i*0.01)));
};
document.getElementById("noteHigh").onclick = () => {
	if (!ctx) return;
	voices.forEach((v,i)=>setVoiceNote(v, 220 * (1 + i*0.01)));
};
</script>
</body>
</html>
