<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Organic Deep String Drone</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
	body{
		margin:0;
		background:#03060b;
		color:#e5ecf7;
		font-family:system-ui,-apple-system,blinkmacsystemfont,sans-serif;
		display:flex;
		flex-direction:column;
		align-items:center;
		justify-content:center;
		height:100vh;
	}
	.wrap{
		width:100%;
		max-width:480px;
		padding:18px;
		box-sizing:border-box;
		display:flex;
		flex-direction:column;
		gap:14px;
	}
	h1{
		margin:0;
		font-size:17px;
		font-weight:500;
		color:#9fb4ff;
		text-align:center;
	}
	button{
		background:#111826;
		color:#e5ecf7;
		border:1px solid #313b52;
		border-radius:10px;
		padding:10px 14px;
		font-size:13px;
		flex:1;
	}
	button:active{
		background:#1a2233;
	}
	.row{
		display:flex;
		gap:8px;
	}
	label{
		display:flex;
		flex-direction:column;
		flex:1;
		font-size:10px;
		color:#8a96b5;
	}
	input[type=range]{
		width:100%;
	}
	.note{
		font-size:10px;
		color:#6b7693;
		text-align:center;
	}
</style>
</head>
<body>
<div class="wrap">
	<h1>Organic Deep String Drone</h1>
	<div class="row">
		<button id="start">Start / Resume</button>
		<button id="stop">Stop</button>
	</div>
	<div class="row">
		<button id="low">Low</button>
		<button id="mid">Mid</button>
		<button id="high">High</button>
	</div>
	<div class="row">
		<label>Bow / Bite
			<input id="bow" type="range" min="0" max="1" step="0.001" value="0.4">
		</label>
	</div>
	<div class="row">
		<label>Density
			<input id="density" type="range" min="0" max="1" step="0.001" value="0.7">
		</label>
		<label>Drift
			<input id="drift" type="range" min="0" max="1" step="0.001" value="0.5">
		</label>
		<label>Air
			<input id="air" type="range" min="0" max="1" step="0.001" value="0.25">
		</label>
	</div>
	<div class="note">
		Deep procedural drone. Bow adds stringy bite, not just hiss.
	</div>
</div>

<script>
let ctx, master;
const voices = [];
let noiseBuffer = null;

let targetBase = 65; // global target fundamental
let baseFreq = 65;

// UI
const bowEl = document.getElementById("bow");
const densityEl = document.getElementById("density");
const driftEl = document.getElementById("drift");
const airEl = document.getElementById("air");

function getNoiseBuffer(audioCtx){
	if (noiseBuffer) return noiseBuffer;
	const rate = audioCtx.sampleRate || 44100;
	const length = rate * 2;
	noiseBuffer = audioCtx.createBuffer(1, length, rate);
	const d = noiseBuffer.getChannelData(0);
	for (let i = 0; i < length; i++) {
		d[i] = (Math.random() * 2 - 1) * 0.7;
	}
	return noiseBuffer;
}

function makeWaveshaper(amount){
	const n = 1024;
	const curve = new Float32Array(n);
	const k = amount;
	for (let i = 0; i < n; i++) {
		let x = (i / (n - 1)) * 2 - 1;
		// soft saturation with a bit of edge
		curve[i] = Math.tanh(x * k);
	}
	return curve;
}

function clamp01(x){ return x < 0 ? 0 : x > 1 ? 1 : x; }

function createVoice(offsetCents = 0){
	const v = {};
	v.gain = ctx.createGain();
	v.gain.gain.value = 0.0;

	// === Noise / friction source ===
	v.noise = ctx.createBufferSource();
	v.noise.buffer = getNoiseBuffer(ctx);
	v.noise.loop = true;

	// Colored friction:
	v.fricBP = ctx.createBiquadFilter(); // main rosin band
	v.fricBP.type = "bandpass";
	v.fricBP.frequency.value = 400;
	v.fricBP.Q.value = 1.4;

	v.fricLP = ctx.createBiquadFilter(); // tame highs
	v.fricLP.type = "lowpass";
	v.fricLP.frequency.value = 2800;
	v.fricLP.Q.value = 0.7;

	v.hairBP = ctx.createBiquadFilter(); // tiny scratch band
	v.hairBP.type = "bandpass";
	v.hairBP.frequency.value = 3400;
	v.hairBP.Q.value = 4.0;

	v.noiseGain = ctx.createGain();
	v.noiseGain.gain.value = 0.0; // base friction level set later

	// route noise
	v.noise.connect(v.fricBP);
	v.fricBP.connect(v.fricLP);
	v.fricLP.connect(v.noiseGain);

	v.noise.connect(v.hairBP);
	const hairGain = ctx.createGain();
	hairGain.gain.value = 0.015; // very subtle
	v.hairBP.connect(hairGain);
	hairGain.connect(v.noiseGain);

	// === Bow-locked AM on friction (stringy bite) ===
	v.bowAM = ctx.createOscillator();
	v.bowAM.frequency.value = baseFreq * 2;
	v.bowAMGain = ctx.createGain();
	v.bowAMGain.gain.value = 0.0; // depth set by bow

	v.bowAM.connect(v.bowAMGain);
	v.bowAMGain.connect(v.noiseGain.gain);

	// === Harmonic cluster ===
	v.partials = [];
	const ratios = [1.0, 2.01, 3.0, 4.03, 5.1, 6.0];
	ratios.forEach((r, idx) => {
		const osc = ctx.createOscillator();
		osc.type = "sine";
		const g = ctx.createGain();
		g.gain.value = 0.0;
		osc.connect(g);
		osc.start();
		v.partials.push({
			osc,
			gain: g,
			ratio: r,
			ampRandom: 0.8 + Math.random() * 0.3,
			detune: offsetCents + (Math.random() - 0.5) * 3
		});
	});

	// === Body resonances ===
	const modeFreqs = [220, 420, 650, 980, 1550, 2300];
	v.bodyFilters = modeFreqs.map(f => {
		const b = ctx.createBiquadFilter();
		b.type = "bandpass";
		b.frequency.value = f;
		b.Q.value = 3.0;
		return b;
	});

	const bodyMix = ctx.createGain();
	bodyMix.gain.value = 1.0;

	// feed noise + partials into body
	v.noiseGain.connect(bodyMix);
	v.partials.forEach(p => p.gain.connect(bodyMix));

	const bodyOut = ctx.createGain();
	bodyOut.gain.value = 1.0;

	v.bodyFilters.forEach(b => {
		bodyMix.connect(b);
		b.connect(bodyOut);
	});

	// === Gentle saturation path (bow -> bite) ===
	v.satPre = ctx.createGain();
	v.satPre.gain.value = 1.0;

	v.satWS = ctx.createWaveShaper();
	v.satWS.curve = makeWaveshaper(2.5);
	v.satWS.oversample = "4x";

	v.satMix = ctx.createGain();
	v.satMix.gain.value = 0.08; // base bite amount

	bodyOut.connect(v.satPre);
	v.satPre.connect(v.satWS);
	v.satWS.connect(v.satMix);

	// === Short feedback space ===
	const delay = ctx.createDelay(0.25);
	delay.delayTime.value = 0.055 + Math.random() * 0.008;
	const fb = ctx.createGain();
	fb.gain.value = 0.21;
	bodyOut.connect(delay);
	delay.connect(fb);
	fb.connect(delay);

	const wet = ctx.createGain();
	wet.gain.value = 0.23;
	delay.connect(wet);

	const dry = ctx.createGain();
	dry.gain.value = 1.0;
	bodyOut.connect(dry);

	// Mix: warm body + space + saturation
	dry.connect(v.gain);
	wet.connect(v.gain);
	v.satMix.connect(v.gain);

	v.gain.connect(master);

	v.noise.start();
	v.bowAM.start();

	v.f0 = baseFreq;
	v.targetF0 = baseFreq * (1 + (offsetCents / 1200));

	voices.push(v);
	return v;
}

function retuneVoice(v){
	const now = ctx.currentTime;
	const density = parseFloat(densityEl.value);
	const drift = parseFloat(driftEl.value);
	const bow = parseFloat(bowEl.value);

	// smooth global base
	v.f0 += (v.targetF0 - v.f0) * 0.01;

	// harmonic cluster evolution
	v.partials.forEach((p, idx) => {
		const baseAmp = (1 / Math.pow(idx + 1, 1.15)) * (0.5 + 0.7 * density);
		const jitter = (Math.random() - 0.5) * 0.02 * drift;
		p.ampRandom = clamp01(p.ampRandom + jitter);
		const amp = baseAmp * (0.6 + 0.4 * p.ampRandom);
		p.gain.gain.linearRampToValueAtTime(amp, now + 0.06);

		const detuneDrift = (Math.random() - 0.5) * 0.2 * drift;
		p.detune = Math.max(-14, Math.min(14, p.detune + detuneDrift));

		const freq = v.f0 * p.ratio;
		p.osc.frequency.linearRampToValueAtTime(freq, now + 0.06);
		p.osc.detune.linearRampToValueAtTime(p.detune, now + 0.06);
	});

	// bow-locked AM: ties friction to string rate for bite
	const fricCenter = v.f0 * 2.2;
	v.fricBP.frequency.linearRampToValueAtTime(
		Math.max(120, Math.min(1200, fricCenter)),
		now + 0.06
	);

	// base friction level + bow control
	const baseFric = 0.003 + bow * 0.055;
	v.noiseGain.gain.setTargetAtTime(baseFric, now, 0.03);

	// AM depth increases with bow for scratchiness
	const amDepth = bow * 0.035;
	v.bowAM.frequency.linearRampToValueAtTime(v.f0 * 2, now + 0.06);
	v.bowAMGain.gain.linearRampToValueAtTime(amDepth, now + 0.06);

	// saturation drive & mix track bow (more bow = more edge)
	const preGain = 1.0 + bow * 6.0;
	const satLevel = 0.04 + bow * 0.3;
	v.satPre.gain.linearRampToValueAtTime(preGain, now + 0.05);
	v.satMix.gain.linearRampToValueAtTime(satLevel, now + 0.05);

	// body modes: subtle detuning motion
	v.bodyFilters.forEach((b) => {
		const wobble = 1 + ((Math.random() - 0.5) * 0.012 * drift);
		const f = b.frequency.value * wobble;
		b.frequency.linearRampToValueAtTime(f, now + 0.09);
	});

	// overall level per voice
	const voiceLevel = (0.5 + 0.35 * density) / voices.length;
	v.gain.gain.linearRampToValueAtTime(voiceLevel, now + 0.08);
}

let lastTime = null;
function loop(t){
	if (!ctx || ctx.state !== "running") return;

	if (!lastTime) lastTime = t;
	lastTime = t;

	// glide global base frequency
	baseFreq += (targetBase - baseFreq) * 0.004;

	const air = parseFloat(airEl.value);
	const now = ctx.currentTime;
	master.gain.linearRampToValueAtTime(0.6 + air * 0.25, now + 0.05);

	voices.forEach(v => {
		// keep each voice slightly offset from global
		v.targetF0 = baseFreq * (1 + ((Math.random() - 0.5) * 0.0015));
		retuneVoice(v);
	});

	requestAnimationFrame(loop);
}

// Start / Resume
document.getElementById("start").onclick = async () => {
	if (!ctx) {
		ctx = new (window.AudioContext || window.webkitAudioContext)();
		master = ctx.createGain();
		master.gain.value = 0.0;
		master.connect(ctx.destination);

		// ensemble of 3 voices with tiny detune offsets
		createVoice(-4);
		createVoice(0);
		createVoice(3);

		const now = ctx.currentTime;
		master.gain.linearRampToValueAtTime(0.8, now + 2.5);

		requestAnimationFrame(loop);
	} else {
		if (ctx.state !== "running") {
			await ctx.resume();
			requestAnimationFrame(loop);
		}
	}
};

// Stop (fade out and suspend)
document.getElementById("stop").onclick = () => {
	if (!ctx) return;
	const now = ctx.currentTime;
	master.gain.cancelScheduledValues(now);
	master.gain.linearRampToValueAtTime(0.0, now + 1.0);
	setTimeout(() => {
		if (ctx && ctx.state === "running") {
			ctx.suspend();
		}
	}, 1100);
};

// Base pitch macros
document.getElementById("low").onclick = () => {
	if (!ctx) return;
	targetBase = 45;
};
document.getElementById("mid").onclick = () => {
	if (!ctx) return;
	targetBase = 70;
};
document.getElementById("high").onclick = () => {
	if (!ctx) return;
	targetBase = 110;
};
</script>
</body>
	</html>
