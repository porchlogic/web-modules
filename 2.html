<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Lush Drone â€” dual note + throat + MORPH + WARMTH</title>
<style>
	body{margin:0;background:#0b0f14;color:#e8eef6;font:14px system-ui}
	.wrap{max-width:1000px;margin:0 auto;padding:16px}
	h1{font-size:18px;margin:6px 0 10px}
	.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px}
	.card{background:#121826;border:1px solid #1e2a3a;border-radius:12px;padding:12px}
	.row{display:flex;align-items:center;gap:10px;margin:8px 0}
	label{flex:1;color:#a8b6c7;font-size:12px}
	input[type=range]{width:170px}
	select,button{border:1px solid #243149;background:#141e2b;color:#e8eef6;padding:8px 10px;border-radius:10px;cursor:pointer}
	.btn[disabled]{opacity:.5;cursor:not-allowed}
	.muted{font-size:12px;color:#9fb3c8}
	.top{display:grid;grid-template-columns:1fr auto auto auto;gap:8px;align-items:center}
	.master{background:#0f1523;border:1px solid #21314a;border-radius:12px;padding:10px}
	.kf{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
	.kf small{opacity:.8}
	.badge{display:inline-block;padding:2px 6px;border-radius:8px;background:#182235;border:1px solid #2a3b5b;font-size:11px}
</style>
<body>
<div class="wrap">
	<h1>ðŸŒŒ Lush Drone â€” Dual Note + Throat + <span class="badge">Master Morph</span> + <span class="badge">Warmth</span></h1>

	<div class="card master">
		<div class="top">
			<div class="row" style="margin:0">
				<label style="min-width:110px">Master Morph</label>
				<input id="morph" type="range" min="0" max="1" step="0.001" value="0">
			</div>
			<button id="saveKF">Save snapshot</button>
			<button id="snapTo" title="Move master to nearest snapshot">Snap to nearest</button>
			<button id="clearKF" title="Remove all snapshots">Clear</button>
		</div>
		<div class="kf"><small>Snapshots:</small><span id="kfList" class="muted">none</span></div>
		<div class="muted">Set the controls â†’ choose a master position â†’ <b>Save snapshot</b>. Sweep the master to morph between states.</div>
	</div>

	<div class="row" style="margin:10px 0">
		<button id="start" class="btn">START</button>
		<button id="stop" class="btn" disabled>STOP</button>
		<span id="status" class="muted">idle</span>
	</div>

	<div class="grid">
		<div class="card">
			<h3>Master & Tone</h3>
			<div class="row"><label>Volume</label><input id="vol" type="range" min="0" max="1" step="0.001" value="0.28"></div>
			<div class="row"><label>Brightness (LPF)</label><input id="cut" type="range" min="200" max="8000" step="1" value="1600"></div>
			<div class="row"><label>Noise</label><input id="noise" type="range" min="0" max="1" step="0.001" value="0.12"></div>
			<div class="row"><label>Delay Mix</label><input id="dmix" type="range" min="0" max="1" step="0.001" value="0.22"></div>
			<div class="row"><label>Delay Time (ms)</label><input id="dtime" type="range" min="100" max="900" step="1" value="420"></div>
			<div class="row"><label>Delay Feedback</label><input id="dfb" type="range" min="0" max="0.9" step="0.001" value="0.45"></div>
			<div class="row"><label>Reverb Mix</label><input id="rmix" type="range" min="0" max="1" step="0.001" value="0.48"></div>
		</div>

		<div class="card">
			<h3>Note A (root)</h3>
			<div class="row"><label>Pitch A (Hz)</label><input id="pitchA" type="range" min="30" max="200" step="0.01" value="65.41"></div>
			<div class="row"><label>Detune A (cents)</label><input id="detA" type="range" min="0" max="40" step="0.1" value="12"></div>
			<div class="row"><label>Sub A</label><input id="subA" type="range" min="0" max="1" step="0.001" value="0.3"></div>
			<div class="row"><label>Level A</label><input id="levA" type="range" min="0" max="1" step="0.001" value="0.9"></div>
		</div>

		<div class="card">
			<h3>Note B (second)</h3>
			<div class="row"><label>Interval</label>
				<select id="interval">
					<option value="0">Unison (0)</option>
					<option value="3">m3 (+3)</option>
					<option value="4" selected>M3 (+4)</option>
					<option value="5">P4 (+5)</option>
					<option value="7">P5 (+7)</option>
					<option value="10">m7 (+10)</option>
					<option value="12">Oct (+12)</option>
				</select>
			</div>
			<div class="row"><label>Detune B (cents)</label><input id="detB" type="range" min="0" max="40" step="0.1" value="16"></div>
			<div class="row"><label>Sub B</label><input id="subB" type="range" min="0" max="1" step="0.001" value="0.18"></div>
			<div class="row"><label>Level B</label><input id="levB" type="range" min="0" max="1" step="0.001" value="0.65"></div>
			<div class="row"><label>Slow Glide (sec)</label><input id="glide" type="range" min="0" max="5" step="0.01" value="1.2"></div>
		</div>

		<div class="card">
			<h3>Throat (overtone feel)</h3>
			<div class="row"><label>Vowel (Aâ€“Eâ€“Iâ€“Oâ€“U)</label><input id="vowel" type="range" min="0" max="1" step="0.001" value="0.15"></div>
			<div class="row"><label>Formant Q</label><input id="formantQ" type="range" min="2" max="25" step="0.1" value="12"></div>
			<div class="row"><label>Throat Mix</label><input id="throatMix" type="range" min="0" max="1" step="0.001" value="0.55"></div>
			<div class="row"><label>Comb Amount</label><input id="combMix" type="range" min="0" max="1" step="0.001" value="0.35"></div>
			<div class="row"><label>Comb Pitch (ms)</label><input id="combMs" type="range" min="2" max="14" step="0.01" value="7.6"></div>
		</div>

		<div class="card">
			<h3>Warmth</h3>
			<div class="row"><label>Warmth Drive</label><input id="warmDrive" type="range" min="0.8" max="1.8" step="0.001" value="1.2"></div>
			<div class="row"><label>Low Lift (dB)</label><input id="lowLift" type="range" min="0" max="4" step="0.01" value="1.8"></div>
			<div class="row"><label>High Trim (dB)</label><input id="highTrim" type="range" min="-3" max="0" step="0.01" value="-1.5"></div>
			<div class="row"><label>Drift Depth</label><input id="driftDepth" type="range" min="0" max="1" step="0.001" value="0.6"></div>
		</div>
	</div>

	<p class="muted">Tip: start with Driveâ‰ˆ1.2, Lowâ‰ˆ+2 dB, Highâ‰ˆâˆ’1.5 dB, Driftâ‰ˆ0.5. Save 3â€“6 snapshots, then sweep the master.</p>
</div>

<script>
(()=> {
	// ===== AUDIO CORE =====
	let ctx, started=false;
	let master, lp, comp, limiter, dryBus, postTone;
	let delay, delayGain, fb, convolver, revGain, noise, noiseGain;

	// Warmth stage nodes
	let preSat, sat, lowShelf, highShelf, outBus;

	// Analog drift
	let driftId = 0;

	const A = {osc:[], pans:[], gains:[], sub:null, subG:null, level:null};
	const B = {osc:[], pans:[], gains:[], sub:null, subG:null, level:null};
	let throatIn, throatOut, f1, f2, combMixGain, combDelay, combLP, combFB;

	const $ = id => document.getElementById(id);
	const setStatus = t => { $('status').textContent = t; };
	const semitone = s => Math.pow(2, s/12);
	const setTarget = (p, v, sec=0.2) => p.setTargetAtTime(v, ctx.currentTime, Math.max(0.02, sec*0.3));

	function mkLimiterCurve(){ const n=65536,c=new Float32Array(n),cut=0.9; for(let i=0;i<n;i++){ const x=i/n*2-1; c[i]=Math.tanh((x/cut)*2.8);} return c; }
	function mkReverbImpulse(seconds=3.0,decay=2.6){
		const len=(seconds*ctx.sampleRate)|0,buf=ctx.createBuffer(2,len,ctx.sampleRate);
		for(let ch=0;ch<2;ch++){ const d=buf.getChannelData(ch); for(let i=0;i<len;i++){ const t=1-i/len; d[i]=(Math.random()*2-1)*Math.pow(t,decay); } }
		return buf;
	}
	function mkSaturationCurve(){
		const n=65536, c=new Float32Array(n);
		for(let i=0;i<n;i++){ const x=i/n*2-1; c[i] = Math.tanh(1.6*x)*0.85; }
		return c;
	}
	function makeVoice(baseHz, detC, subAmt, levelAmt){
		const v = {osc:[], pans:[], gains:[], sub:null, subG:null, level:null};
		const waves=['sawtooth','triangle','sine'], freqs=[1,2,3], spreads=[-detC,detC*0.6,detC];
		for(let i=0;i<3;i++){
			const o=ctx.createOscillator(); o.type=waves[i%3]; o.frequency.value=baseHz*freqs[i]; o.detune.value=spreads[i];
			const g=ctx.createGain(); g.gain.value=[0.22,0.18,0.14][i];
			const p=ctx.createStereoPanner(); p.pan.value=[-0.35,0.35,0][i];
			o.connect(g).connect(p).connect(dryBus); o.start();
			v.osc.push(o); v.gains.push(g); v.pans.push(p);
		}
		v.sub=ctx.createOscillator(); v.sub.type='sine'; v.sub.frequency.value=baseHz/2;
		v.subG=ctx.createGain(); v.subG.gain.value=subAmt;
		v.sub.connect(v.subG).connect(dryBus); v.sub.start();

		// voice level block
		v.level=ctx.createGain(); v.level.gain.value=levelAmt;
		for(let i=0;i<v.gains.length;i++){ v.gains[i].disconnect(); v.gains[i].connect(v.level).connect(v.pans[i]).connect(dryBus); }
		v.subG.disconnect(); v.subG.connect(v.level).connect(dryBus);
		return v;
	}
	function cleanupVoice(v){ try{ v.osc.forEach(o=>o.stop()); v.sub && v.sub.stop(); }catch(e){} v.osc=[]; v.pans=[]; v.gains=[]; }

	function applyVowel(x){
		const tbl=[{F1:800,F2:1150},{F1:500,F2:1700},{F1:350,F2:2200},{F1:450,F2:800},{F1:325,F2:700}];
		const seg=Math.min(tbl.length-2, Math.floor(x*(tbl.length-1)));
		const t=(x*(tbl.length-1))-seg, a=tbl[seg], b=tbl[seg+1];
		setTarget(f1.frequency, a.F1+(b.F1-a.F1)*t, 0.15);
		setTarget(f2.frequency, a.F2+(b.F2-a.F2)*t, 0.15);
	}

	function wireWarmthChain(){
		// postTone -> preSat -> sat -> lowShelf -> highShelf -> FX/dry/out
		preSat = ctx.createGain();        preSat.gain.value = +$('warmDrive').value;  // "drive"
		sat    = ctx.createWaveShaper();  sat.curve = mkSaturationCurve();
		lowShelf  = ctx.createBiquadFilter(); lowShelf.type='lowshelf';  lowShelf.frequency.value=180;  lowShelf.gain.value= +$('lowLift').value;
		highShelf = ctx.createBiquadFilter(); highShelf.type='highshelf'; highShelf.frequency.value=5200; highShelf.gain.value= +$('highTrim').value;

		postTone.connect(preSat).connect(sat).connect(lowShelf).connect(highShelf);

		// FX now fed from warmed signal
		highShelf.connect(delay).connect(fb).connect(delay);
		delay.connect(delayGain);
		highShelf.connect(convolver).connect(revGain);

		outBus = ctx.createGain();
		highShelf.connect(outBus);
		delayGain.connect(outBus);
		revGain.connect(outBus);
		outBus.connect(comp).connect(limiter).connect(master).connect(ctx.destination);
	}

	function startDrift(){
		const depth = +$('driftDepth').value; // 0..1
		const baseStep = 0.015 * depth;
		const baseFlutter = 0.6 * depth;
		function step(val, s){ return val + (Math.random()-0.5)*s; }

		let a=[0,0,0], b=[0,0,0], f=0;
		const t0 = performance.now();
		function tick(){
			const t = (performance.now()-t0)/1000;
			for(let i=0;i<3;i++){ a[i]=step(a[i], baseStep); }
			for(let i=0;i<3;i++){ b[i]=step(b[i], baseStep); }
			const flutter = Math.sin(t*2*Math.PI*0.7)*baseFlutter;

			// apply to detune around the slider baselines
			if (A.osc[0]) A.osc[0].detune.setTargetAtTime(-+$('detA').value + a[0] + flutter, ctx.currentTime, 0.25);
			if (A.osc[1]) A.osc[1].detune.setTargetAtTime( +$('detA').value*0.6 + a[1], ctx.currentTime, 0.25);
			if (A.osc[2]) A.osc[2].detune.setTargetAtTime( +$('detA').value + a[2], ctx.currentTime, 0.25);

			if (B.osc[0]) B.osc[0].detune.setTargetAtTime(-+$('detB').value + b[0] + flutter*0.8, ctx.currentTime, 0.25);
			if (B.osc[1]) B.osc[1].detune.setTargetAtTime( +$('detB').value*0.6 + b[1], ctx.currentTime, 0.25);
			if (B.osc[2]) B.osc[2].detune.setTargetAtTime( +$('detB').value + b[2], ctx.currentTime, 0.25);

			// filter breathing Â± depth*120 Hz around current cutoff
			f = step(f, 0.6*depth);
			const baseCut = +$('cut').value;
			lp.frequency.setTargetAtTime(Math.max(150, baseCut + Math.sin(t*0.12)* (90*depth) + f), ctx.currentTime, 0.3);

			driftId = requestAnimationFrame(tick);
		}
		driftId = requestAnimationFrame(tick);
	}

	async function startAudio(){
		if(started) return;
		ctx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
		try { await ctx.resume(); } catch(e) {}

		// master & protection
		master=ctx.createGain(); master.gain.value=0.0001;
		comp=ctx.createDynamicsCompressor(); comp.threshold.value=-22; comp.knee.value=18; comp.ratio.value=2.5; comp.attack.value=0.01; comp.release.value=0.2;
		limiter=ctx.createWaveShaper(); limiter.curve=mkLimiterCurve();

		// buses
		dryBus=ctx.createGain(); postTone=ctx.createGain();

		// tone pre-warmth
		lp=ctx.createBiquadFilter(); lp.type='lowpass'; lp.Q.value=0.7; lp.frequency.value=+$('cut').value;
		dryBus.connect(lp).connect(postTone);

		// noise
		const nbuf=ctx.createBuffer(1,ctx.sampleRate*2,ctx.sampleRate);
		const nd=nbuf.getChannelData(0); for(let i=0;i<nd.length;i++) nd[i]=(Math.random()*2-1)*0.6;
		noise=ctx.createBufferSource(); noise.buffer=nbuf; noise.loop=true;
		noiseGain=ctx.createGain(); noiseGain.gain.value=+$('noise').value;
		noise.connect(noiseGain).connect(dryBus); noise.start();

		// FX scaffolding (wired after warmth)
		delay=ctx.createDelay(1.2); delay.delayTime.value=+$('dtime').value/1000;
		fb=ctx.createGain(); fb.gain.value=+$('dfb').value;
		delayGain=ctx.createGain(); delayGain.gain.value=+$('dmix').value;

		convolver=ctx.createConvolver(); convolver.buffer=mkReverbImpulse(3.2,2.8);
		revGain=ctx.createGain(); revGain.gain.value=+$('rmix').value;

		// voices
		const baseA=+$('pitchA').value; Object.assign(A, makeVoice(baseA, +$('detA').value, +$('subA').value, +$('levA').value));
		const baseB=baseA*semitone(+$('interval').value); Object.assign(B, makeVoice(baseB, +$('detB').value, +$('subB').value, +$('levB').value));

		// throat
		throatIn=ctx.createGain(); throatOut=ctx.createGain(); throatOut.gain.value=+$('throatMix').value;
		f1=ctx.createBiquadFilter(); f1.type='bandpass'; f1.Q.value=+$('formantQ').value;
		f2=ctx.createBiquadFilter(); f2.type='bandpass'; f2.Q.value=+$('formantQ').value;
		dryBus.connect(throatIn); throatIn.connect(f1).connect(throatOut); throatIn.connect(f2).connect(throatOut);
		combDelay=ctx.createDelay(0.05); combLP=ctx.createBiquadFilter(); combLP.type='lowpass'; combLP.frequency.value=5000;
		combFB=ctx.createGain(); combFB.gain.value=0.75; combMixGain=ctx.createGain(); combMixGain.gain.value=+$('combMix').value;
		throatIn.connect(combDelay).connect(combLP).connect(combFB).connect(combDelay); combDelay.connect(combMixGain);
		throatOut.connect(postTone); combMixGain.connect(postTone);
		combDelay.delayTime.value=+$('combMs').value/1000; applyVowel(+$('vowel').value);

		// warmth chain (postTone â†’ sat â†’ tilt â†’ FX/dry/out)
		wireWarmthChain();

		// fade in
		setTarget(master.gain, +$('vol').value, 0.25);

		// start analog drift
		startDrift();

		started=true; $('start').disabled=true; $('stop').disabled=false; setStatus('running');
	}

	function stopAudio(){
		if(!started) return;
		setTarget(master.gain,0.00001,0.25);
		if (typeof driftId === 'number') cancelAnimationFrame(driftId);
		setTimeout(()=>{ ctx.close(); started=false; $('start').disabled=false; $('stop').disabled=true; setStatus('stopped'); },350);
	}

	function applyParams(){
		if(!started) return;
		setTarget(master.gain, +$('vol').value, 0.15);
		setTarget(lp.frequency, +$('cut').value, 0.1);
		setTarget(noiseGain.gain, +$('noise').value, 0.2);

		// FX
		setTarget(delay.delayTime, +$('dtime').value/1000, 0.1);
		setTarget(fb.gain, +$('dfb').value, 0.2);
		setTarget(delayGain.gain, +$('dmix').value, 0.1);
		setTarget(revGain.gain, +$('rmix').value, 0.2);

		// throat
		f1.Q.setTargetAtTime(+$('formantQ').value, ctx.currentTime, 0.15);
		f2.Q.setTargetAtTime(+$('formantQ').value, ctx.currentTime, 0.15);
		throatOut.gain.setTargetAtTime(+$('throatMix').value, ctx.currentTime, 0.15);
		combMixGain.gain.setTargetAtTime(+$('combMix').value, ctx.currentTime, 0.15);
		combDelay.delayTime.setTargetAtTime(+$('combMs').value/1000, ctx.currentTime, 0.1);

		// voices
		const glide=+$('glide').value;
		A.osc.forEach((o,i)=>o.frequency.setTargetAtTime(+$('pitchA').value*[1,2,3][i], ctx.currentTime, glide));
		A.sub.frequency.setTargetAtTime(+$('pitchA').value/2, ctx.currentTime, glide);
		A.osc[0].detune.setTargetAtTime(-+$('detA').value, ctx.currentTime, 0.2);
		A.osc[1].detune.setTargetAtTime(+$('detA').value*0.6, ctx.currentTime, 0.2);
		A.osc[2].detune.setTargetAtTime(+$('detA').value, ctx.currentTime, 0.2);
		A.subG.gain.setTargetAtTime(+$('subA').value, ctx.currentTime, 0.2);
		A.level.gain.setTargetAtTime(+$('levA').value, ctx.currentTime, 0.2);

		const baseB=+$('pitchA').value*semitone(+$('interval').value);
		B.osc.forEach((o,i)=>o.frequency.setTargetAtTime(baseB*[1,2,3][i], ctx.currentTime, glide));
		B.sub.frequency.setTargetAtTime(baseB/2, ctx.currentTime, glide);
		B.osc[0].detune.setTargetAtTime(-+$('detB').value, ctx.currentTime, 0.2);
		B.osc[1].detune.setTargetAtTime(+$('detB').value*0.6, ctx.currentTime, 0.2);
		B.osc[2].detune.setTargetAtTime(+$('detB').value, ctx.currentTime, 0.2);
		B.subG.gain.setTargetAtTime(+$('subB').value, ctx.currentTime, 0.2);
		B.level.gain.setTargetAtTime(+$('levB').value, ctx.currentTime, 0.2);

		// warmth params
		if (preSat) preSat.gain.setTargetAtTime(+$('warmDrive').value, ctx.currentTime, 0.15);
		if (lowShelf) lowShelf.gain.setTargetAtTime(+$('lowLift').value, ctx.currentTime, 0.2);
		if (highShelf) highShelf.gain.setTargetAtTime(+$('highTrim').value, ctx.currentTime, 0.2);
		// drift depth applies next drift frame (no direct param, but UI capture affects tick)
	}

	// ===== MORPH SYSTEM =====
	const PARAM_IDS = [
		'vol','cut','noise','dmix','dtime','dfb','rmix',
		'pitchA','detA','subA','levA','interval','detB','subB','levB','glide',
		'vowel','formantQ','throatMix','combMix','combMs',
		'warmDrive','lowLift','highTrim','driftDepth'
	];
	let snapshots = [];
	let updatingUI = false;

	function getParamVector(){ const p={}; for(const id of PARAM_IDS){ p[id]=+($(id).value); } return p; }
	function setParamVector(p){ updatingUI=true; for(const id of PARAM_IDS){ if(p[id]==null) continue; $(id).value=p[id]; } updatingUI=false; applyParams(); }
	function lerp(a,b,t){ return a+(b-a)*t; }
	function interp(a,b,t){ const out={}; for(const id of PARAM_IDS){ out[id]=lerp(a[id],b[id],t); } return out; }
	function findNeighbors(x){
		if(snapshots.length===0) return [null,null,0];
		if(snapshots.length===1) return [snapshots[0],snapshots[0],0];
		let left=snapshots[0], right=snapshots[snapshots.length-1];
		if(x<=left.pos) return [left,left,0];
		if(x>=right.pos) return [right,right,0];
		for(let i=0;i<snapshots.length-1;i++){
			const a=snapshots[i], b=snapshots[i+1];
			if(x>=a.pos && x<=b.pos){ const t=(x-a.pos)/Math.max(1e-9,(b.pos-a.pos)); return [a,b,t]; }
		}
		return [left,right,0];
	}
	function updateSnapshotListUI(){ $('kfList').textContent = snapshots.length? snapshots.map(s=>s.pos.toFixed(2)).join(' â€¢ ') : 'none'; }
	function saveSnapshotAt(pos){
		const p=getParamVector(), EPS=0.01;
		const idx=snapshots.findIndex(s=>Math.abs(s.pos-pos)<EPS);
		if(idx>=0) snapshots[idx]={pos,p}; else { snapshots.push({pos,p}); snapshots.sort((a,b)=>a.pos-b.pos); }
		updateSnapshotListUI();
	}
	function applyMaster(x){
		$('morph').value=x;
		if(snapshots.length===0) return;
		const [a,b,t]=findNeighbors(x); const p=interp(a.p,b.p,t); setParamVector(p);
	}

	// ===== UI WIRING =====
	$('start').addEventListener('click', startAudio);
	$('stop').addEventListener('click', stopAudio);

	PARAM_IDS.forEach(id=>{
		$(id).addEventListener('input', ()=>{ if(!updatingUI) applyParams(); });
	});
	$('vowel').addEventListener('input', ()=>{ if(started) applyVowel(+$('vowel').value); });

	$('morph').addEventListener('input', e => applyMaster(+e.target.value));
	$('saveKF').addEventListener('click', ()=> saveSnapshotAt(+$('morph').value));
	$('clearKF').addEventListener('click', ()=>{ snapshots=[]; updateSnapshotListUI(); });
	$('snapTo').addEventListener('click', ()=>{
		if(!snapshots.length) return;
		const x=+$('morph').value; let nearest=snapshots[0], best=Math.abs(x-nearest.pos);
		for(const s of snapshots){ const d=Math.abs(x-s.pos); if(d<best){ best=d; nearest=s; } }
		applyMaster(nearest.pos);
	});

	// Safety: resume if the OS suspends audio
	['touchstart','touchend','mousedown','keydown'].forEach(ev=>{
		document.addEventListener(ev, async ()=>{ try{ if(ctx && ctx.state!=='running') await ctx.resume(); }catch(e){} }, {passive:true});
	});
})();
</script>
</body>
</html>
